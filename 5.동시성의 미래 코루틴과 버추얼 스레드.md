# 5.동시성의 미래 코루틴과 버추얼 스레드


## 전통적 웹 방식
![image](https://github.com/user-attachments/assets/d32ad201-2727-4286-a530-4d0ff8e05aa9)
- 스레드가 블록킹되는 특징
- Spring MVC가 가지고 있는 특징

![image](https://github.com/user-attachments/assets/990a526a-1b81-4574-873f-7b2a198f1fee)
- 성능 문제와 직결됨
- 일정 스레드를 미리 생성 후 사용하는 방식으로 동시성 제어를 했었음.
- 그러나 스레드 풀의 개수만큼만 사용할 수 있으며, 스레드 풀만큼 사용하지 않으면 자원이 낭비되는 문제도 있음

### 전통적인 방식의 정리
  ![image](https://github.com/user-attachments/assets/9cc08a09-d108-41b2-b47e-155fdfee5812)

## 리액티브 프로그래밍
![image](https://github.com/user-attachments/assets/d76a609d-3980-49d1-b048-32220cab55cd)
> 콜벡헬 = 콜백 지옥(callback hell): 콜백 함수를 중첩하여 사용할 때 코드가 복잡해지고 가독성이 저하되는 현상
![image](https://github.com/user-attachments/assets/97c26d0d-d447-4631-a339-f26e9a8c3863)
- 콜백헬 문제 해결
- 손쉽게 비동기 문제 해결
- 실시간 데이터 스트리밍에 대한 유연한 처리 가능
- 대규모 트래픽 처리에도 유용

### 배우기 어렵다는 학습 곡선 존재
<img src="https://github.com/user-attachments/assets/9b640e7c-89c7-4f0c-b577-9c758498f571"></img>
![image](https://github.com/user-attachments/assets/293743ee-6c39-45ef-abef-24580af7a075)
![image](https://github.com/user-attachments/assets/084659ed-d744-4dc4-b12e-b8eab59805d0)
- webflux에서 블로킹 API가 호출되면 성능 하락이 큰 폭으로 생긴다.

### 리액티브 프로그래밍 정리
![image](https://github.com/user-attachments/assets/c7d899b8-c93c-41dd-b5cb-78b68fe1be4c)

## 코틀린 코루틴
- 코틀린에서 비동기 프로그래밍을 손쉽게 작성할 수 있게 도와주는 확장 라이브러리다.
![image](https://github.com/user-attachments/assets/c6ae0815-76f6-4da0-89b2-0f55e6cee7a8)
![image](https://github.com/user-attachments/assets/f9efd512-1926-49cb-84ab-67f1875befec)

### 리액티브 코드 -> 코루틴
![image](https://github.com/user-attachments/assets/52b456c2-60c9-4bc3-8ad3-86f45a9fa1c9)
- 전통적인 방식과 유사한 흐름으로 코드를 작성할 수 있다.
- 코루틴은 매우 가볍다.

![image](https://github.com/user-attachments/assets/2e0a2616-f9e2-4fb2-b6ea-aeefabaf50a9)
> 빨간색이 코루틴의 동작 방식에 대한 이미지
- 다수의 코루틴이 platform Thread에서 동작
- 코루틴간의 전환은 언어 레벨에서 이루어진다.

### 전통적인 방식의 스레드 100만개 생성 예제
![image](https://github.com/user-attachments/assets/aa6607eb-d17f-4646-93df-e3e33a6f7957)
![image](https://github.com/user-attachments/assets/a3da1c9d-496d-4e88-b6fe-641abdc7eacb)

### 코루틴에서 스레드 100만개
![image](https://github.com/user-attachments/assets/5772fe50-cd54-4811-bed9-c58d1c4e273b)
![image](https://github.com/user-attachments/assets/3cd8e123-54c6-45db-8cd1-03b5c9a95347)

### 코루틴 빌더
- 코루틴을 생성하는 함수
#### runBlocking
```kotlin
fun main() {
  runBlocking{
    println("Hello")
  }
  println("world")
}
```
- runBlocking에 감싸진 코드는 모든 수행이 끝날 때까지 스레드가 블록킹 된다.
- 테스트 코드, 스프링 배치 등 코루틴을 지원하지 않거나 블로킹 스택과 브릿지하는 경우에 사용
#### launch
```kotlin
fun main() = runBlocking {
  launch{
    delay(500L)
    println("Hello")
  }
  println("world")
}
```
- launch는 스레드 차단 없이 새로운 코루틴을 시작하며 결과를 만들어내지 않는(값을 반환하지 않는) 비동기 작업에 적합

#### async
![image](https://github.com/user-attachments/assets/a30aa3f3-3fb5-4d19-82c6-1dccfd36ce0a)

### 구조적 동시성
- 코루틴의 생명주기와 예측 가능성 향상
![image](https://github.com/user-attachments/assets/2c3f915a-ffad-4d24-9e71-e2064702b82b)
![image](https://github.com/user-attachments/assets/896530be-298d-40b4-9790-5a012143a8e2)
- 관련없는 launch 빌더도 실행이 안됨

<img src="https://github.com/user-attachments/assets/efc18d84-c861-404c-9402-070cada142a6" width="470px" height=""></img>
<img src="https://github.com/user-attachments/assets/1a5f9912-2304-4417-b581-e2ba32feb193" width="470px" height=""></img>
![image](https://github.com/user-attachments/assets/ace0e40f-6816-48b9-8b94-189b76e9d57e)

### 코루틴 컨텍스트
- 코루틴이 실행되는 환경을 제어한다.
![image](https://github.com/user-attachments/assets/6bb0a62c-0371-4be5-8838-84b95310c87f)
> Dispatchers: 코루틴 컨텍스트로서 코루틴이 실행되는 환경을 결정할 수 있음. -> Dispatchers.IO는 IO 처리에 뛰어난 스레드풀에서 동작하도록 설정함

![image](https://github.com/user-attachments/assets/0347f095-7ba1-4851-b3ce-f189eeac229f)
![image](https://github.com/user-attachments/assets/ad7d2015-9417-49b4-a269-1c31617249b2)
- Dispatchers.IO로 인한 스레드 변경으로 인해 async 내부에서 찍은 로그에서는 requestId 정보가 유실되어 있음.
  
> ThreadLocal은 스레드마다 독립적인 값을 저장할 수 있는 메커니즘.
> 즉, 여러 스레드가 동시에 실행될 때, 각 스레드가 ThreadLocal 변수를 읽거나 쓸 때 자신만의 복사본을 가지게 됩니다. 이를 통해 스레드 간에 데이터가 공유되지 않도록 할 수 있음.

> MDC:  로그에서 컨텍스트 정보를 스레드별로 저장하고 활용하기 위한 메커니. 주로 로깅 라이브러리인 SLF4J나 Logback에서 지원되며, 스레드별로 진단 정보를 저장하여 나중에 로그 메시지를 기록할 때 이 정보를 활용할 수 있게 해줌.
> 스레드별 정보 저장: MDC는 내부적으로 ThreadLocal을 사용하여 각 스레드마다 독립적으로 데이터를 저장합니다. 이 덕분에 스레드 간에 컨텍스트 정보가 충돌하지 않고 관리됩니다.
> 컨텍스트 정보 로깅: MDC에 저장된 정보는 로그 출력 시 자동으로 포함될 수 있습니다. 예를 들어, 사용자 ID, 트랜잭션 ID 같은 정보를 MDC에 넣어두면, 해당 스레드에서 실행되는 모든 로그에 이 정보가 함께 출력될 수 있습니다.

![image](https://github.com/user-attachments/assets/b1297fed-fc7f-49e4-a772-4632d0f16534)
- 코루틴의 sl4j 의존성을 추가해서 사용 가능

### 정리
![image](https://github.com/user-attachments/assets/53044830-451b-48a2-bc36-037db1062537)


## 버추얼 스레드

## 코루틴과 버추얼 스레드의 통합
 

